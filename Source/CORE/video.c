#include "video.h"

#include <dos.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <conio.h>
#include <malloc.h>
#include <stdio.h>

#define USE_BACKBUFFER 1

static unsigned char far *const VGA = (unsigned char far *)MK_FP(0xA000, 0x0000);
static unsigned char far *backbuffer = NULL;
static unsigned char locked_palette[256 * 3];
static unsigned char current_palette[256 * 3];
static int palette_locked = 0;

static const unsigned char font8x8_basic[96][8] = {
    { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
    { 0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00 },
    { 0x6C,0x6C,0x24,0x00,0x00,0x00,0x00,0x00 },
    { 0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00 },
    { 0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00 },
    { 0x00,0x66,0x6C,0x18,0x30,0x6C,0xC6,0x00 },
    { 0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00 },
    { 0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00 },
    { 0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00 },
    { 0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00 },
    { 0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00 },
    { 0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00 },
    { 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30 },
    { 0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00 },
    { 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00 },
    { 0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00 },
    { 0x7C,0xC6,0xCE,0xD6,0xE6,0xC6,0x7C,0x00 },
    { 0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00 },
    { 0x7C,0xC6,0x0E,0x1C,0x70,0xC0,0xFE,0x00 },
    { 0x7C,0xC6,0x06,0x3C,0x06,0xC6,0x7C,0x00 },
    { 0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x1E,0x00 },
    { 0xFE,0xC0,0xFC,0x06,0x06,0xC6,0x7C,0x00 },
    { 0x38,0x60,0xC0,0xFC,0xC6,0xC6,0x7C,0x00 },
    { 0xFE,0xC6,0x0C,0x18,0x30,0x30,0x30,0x00 },
    { 0x7C,0xC6,0xC6,0x7C,0xC6,0xC6,0x7C,0x00 },
    { 0x7C,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00 },
    { 0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00 },
    { 0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30 },
    { 0x0E,0x1C,0x38,0x70,0x38,0x1C,0x0E,0x00 },
    { 0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00 },
    { 0x70,0x38,0x1C,0x0E,0x1C,0x38,0x70,0x00 },
    { 0x7C,0xC6,0x0E,0x1C,0x18,0x00,0x18,0x00 },
    { 0x7C,0xC6,0xDE,0xDE,0xDE,0xC0,0x78,0x00 },
    { 0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x00 },
    { 0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00 },
    { 0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00 },
    { 0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00 },
    { 0xFE,0x62,0x68,0x78,0x68,0x62,0xFE,0x00 },
    { 0xFE,0x62,0x68,0x78,0x68,0x60,0xF0,0x00 },
    { 0x3C,0x66,0xC0,0xC0,0xCE,0x66,0x3E,0x00 },
    { 0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00 },
    { 0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00 },
    { 0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00 },
    { 0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00 },
    { 0xF0,0x60,0x60,0x60,0x62,0x66,0xFE,0x00 },
    { 0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0x00 },
    { 0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00 },
    { 0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00 },
    { 0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00 },
    { 0x7C,0xC6,0xC6,0xC6,0xD6,0xCC,0x7A,0x00 },
    { 0xFC,0x66,0x66,0x7C,0x6C,0x66,0xE6,0x00 },
    { 0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00 },
    { 0x7E,0x7E,0x5A,0x18,0x18,0x18,0x3C,0x00 },
    { 0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00 },
    { 0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00 },
    { 0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00 },
    { 0xC6,0xC6,0x6C,0x38,0x38,0x6C,0xC6,0x00 },
    { 0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00 },
    { 0xFE,0xC6,0x8C,0x18,0x32,0x66,0xFE,0x00 },
    { 0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00 },
    { 0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00 },
    { 0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00 },
    { 0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00 },
    { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF },
    { 0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00 },
    { 0x00,0x00,0x7C,0x06,0x7E,0xC6,0x7E,0x00 },
    { 0xE0,0x60,0x7C,0x66,0x66,0x66,0xDC,0x00 },
    { 0x00,0x00,0x7C,0xC6,0xC0,0xC6,0x7C,0x00 },
    { 0x1C,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00 },
    { 0x00,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00 },
    { 0x3C,0x66,0x60,0xF8,0x60,0x60,0xF0,0x00 },
    { 0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0xF8 },
    { 0xE0,0x60,0x6C,0x76,0x66,0x66,0xE6,0x00 },
    { 0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00 },
    { 0x0C,0x00,0x0C,0x0C,0x0C,0xCC,0xCC,0x78 },
    { 0xE0,0x60,0x66,0x6C,0x78,0x6C,0xE6,0x00 },
    { 0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00 },
    { 0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xC6,0x00 },
    { 0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x00 },
    { 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0x00 },
    { 0x00,0x00,0xDC,0x66,0x66,0x7C,0x60,0xF0 },
    { 0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0x1E },
    { 0x00,0x00,0xDC,0x76,0x66,0x60,0xF0,0x00 },
    { 0x00,0x00,0x7E,0xC0,0x7C,0x06,0xFC,0x00 },
    { 0x30,0x30,0xFC,0x30,0x30,0x36,0x1C,0x00 },
    { 0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x76,0x00 },
    { 0x00,0x00,0xC6,0xC6,0xC6,0x6C,0x38,0x00 },
    { 0x00,0x00,0xC6,0xD6,0xD6,0xFE,0x6C,0x00 },
    { 0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00 },
    { 0x00,0x00,0xC6,0xC6,0xC6,0x7E,0x06,0xFC },
    { 0x00,0x00,0xFE,0x4C,0x18,0x32,0xFE,0x00 },
    { 0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00 },
    { 0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00 },
    { 0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00 },
    { 0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00 },
    { 0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0x00 }
};

void v_init_mode13(void)
{
    union REGS regs;

    regs.h.ah = 0x00;
    regs.h.al = 0x13;
    int86(0x10, &regs, &regs);

#if USE_BACKBUFFER
    backbuffer = (unsigned char far *)_fmalloc((unsigned long)VIDEO_WIDTH * VIDEO_HEIGHT);
#endif

}

void v_text_mode(void)
{
    union REGS regs;

    regs.h.ah = 0x00;
    regs.h.al = 0x03;
    int86(0x10, &regs, &regs);

#if USE_BACKBUFFER
    if (backbuffer != NULL) {
        _ffree(backbuffer);
        backbuffer = NULL;
    }
#endif

}

void v_clear(unsigned char color)
{
    unsigned char far *dst;

#if USE_BACKBUFFER
    if (backbuffer != NULL) {
        _fmemset(backbuffer, color, VIDEO_WIDTH * VIDEO_HEIGHT);
        return;
    }
#endif

    dst = VGA;
    _fmemset(dst, color, VIDEO_WIDTH * VIDEO_HEIGHT);
}

static void v_put_pixel(int x, int y, unsigned char color)
{
    if (x < 0 || y < 0 || x >= VIDEO_WIDTH || y >= VIDEO_HEIGHT) {
        return;
    }
#if USE_BACKBUFFER
    if (backbuffer != NULL) {
        backbuffer[y * VIDEO_WIDTH + x] = color;
        return;
    }
#endif
    VGA[y * VIDEO_WIDTH + x] = color;
}

void v_putpixel(int x, int y, unsigned char color)
{
    v_put_pixel(x, y, color);
}

void v_fill_rect(int x, int y, int w, int h, unsigned char color)
{
    int x0;
    int y0;
    int x1;
    int y1;
    int row_w;
    int iy;
    unsigned char far *dst;

    if (w <= 0 || h <= 0) {
        return;
    }

    x0 = x;
    y0 = y;
    x1 = x + w;
    y1 = y + h;

    if (x0 < 0) {
        x0 = 0;
    }
    if (y0 < 0) {
        y0 = 0;
    }
    if (x1 > VIDEO_WIDTH) {
        x1 = VIDEO_WIDTH;
    }
    if (y1 > VIDEO_HEIGHT) {
        y1 = VIDEO_HEIGHT;
    }

    if (x0 >= x1 || y0 >= y1) {
        return;
    }

    row_w = x1 - x0;
#if USE_BACKBUFFER
    if (backbuffer != NULL) {
        dst = backbuffer;
    } else
#endif
    {
        dst = VGA;
    }

    for (iy = y0; iy < y1; ++iy) {
        unsigned char far *row = dst + (iy * VIDEO_WIDTH) + x0;
        _fmemset(row, color, row_w);
    }
}

void v_draw_dotted_rect(int x, int y, int w, int h, unsigned char base_color, unsigned char dot_color,
                        int horizontal)
{
    int ix;
    int iy;
    const int dot_step = 6;
    const int dot_size = 2;
    const int phase = -2;

    for (iy = 0; iy < h; ++iy) {
        for (ix = 0; ix < w; ++ix) {
            v_put_pixel(x + ix, y + iy, base_color);
        }
    }

    if (!horizontal) {
        for (iy = y; iy < y + h; ++iy) {
            int row = iy / dot_step;
            int x_offset = (row % 2) * (dot_step / 2);

            if ((iy % dot_step) != 0) {
                continue;
            }

            for (ix = x; ix < x + w; ++ix) {
                int xa = ix + x_offset + phase;

                if ((xa % dot_step) != 0) {
                    continue;
                }

                {
                    int remaining_w = (x + w) - ix;
                    int remaining_h = (y + h) - iy;
                    int dot_w = remaining_w >= dot_size ? dot_size : remaining_w;
                    int dot_h = remaining_h >= dot_size ? dot_size : remaining_h;
                    int dx;
                    int dy;

                    for (dy = 0; dy < dot_h; ++dy) {
                        for (dx = 0; dx < dot_w; ++dx) {
                            v_put_pixel(ix + dx, iy + dy, dot_color);
                        }
                    }
                }
            }
        }
    } else {
        for (ix = x; ix < x + w; ++ix) {
            int col = ix / dot_step;
            int y_offset = (col % 2) * (dot_step / 2);

            if ((ix % dot_step) != 0) {
                continue;
            }

            for (iy = y; iy < y + h; ++iy) {
                int ya = iy + y_offset + phase;

                if ((ya % dot_step) != 0) {
                    continue;
                }

                {
                    int remaining_w = (x + w) - ix;
                    int remaining_h = (y + h) - iy;
                    int dot_w = remaining_w >= dot_size ? dot_size : remaining_w;
                    int dot_h = remaining_h >= dot_size ? dot_size : remaining_h;
                    int dx;
                    int dy;

                    for (dy = 0; dy < dot_h; ++dy) {
                        for (dx = 0; dx < dot_w; ++dx) {
                            v_put_pixel(ix + dx, iy + dy, dot_color);
                        }
                    }
                }
            }
        }
    }
}

static void v_put_char(int x, int y, char c, unsigned char color)
{
    unsigned char row;
    int i;
    int j;
    unsigned char mask;
    int index;

    if (c < 32 || c > 127) {
        c = '?';
    }
    index = c - 32;

    for (i = 0; i < 8; ++i) {
        row = font8x8_basic[index][i];
        for (j = 0; j < 8; ++j) {
            mask = 1 << (7 - j);
            if (row & mask) {
                v_put_pixel(x + j, y + i, color);
            }
        }
    }
}

void v_puts(int x, int y, const char *text, unsigned char color)
{
    int cursor = 0;

    while (text[cursor] != '\0') {
        v_put_char(x + cursor * 8, y, text[cursor], color);
        ++cursor;
    }
}

static void v_wait_vsync(void)
{
    // Espera fin de retrace actual
    while (inp(0x3DA) & 0x08) { }
    // Espera inicio del siguiente retrace
    while (!(inp(0x3DA) & 0x08)) { }
}

void v_present(void)
{
#if USE_BACKBUFFER
    if (backbuffer != NULL) {
        v_wait_vsync();
        _fmemcpy(VGA, backbuffer, VIDEO_WIDTH * VIDEO_HEIGHT);
    }
#endif
}

unsigned char far *v_backbuffer_ptr(void)
{
#if USE_BACKBUFFER
    return backbuffer;
#else
    return VGA;
#endif
}

void v_present_fast(void)
{
#if USE_BACKBUFFER
    if (backbuffer != NULL) {
        _fmemcpy(VGA, backbuffer, VIDEO_WIDTH * VIDEO_HEIGHT);
    }
#endif
}

void v_blit_fullscreen_fast(const unsigned char far *src)
{
    unsigned char far *dst = v_backbuffer_ptr();
    if (!src || !dst) {
        return;
    }
    _fmemcpy(dst, src, VIDEO_WIDTH * VIDEO_HEIGHT);
}

void v_blit_sprite(int x, int y, int w, int h, const unsigned char far *pixels, unsigned char transparent)
{
    int sx, sy;
    int dx, dy;
    unsigned char p;

    if (w <= 0 || h <= 0) return;

    for (sy = 0; sy < h; ++sy) {
        dy = y + sy;
        if (dy < 0 || dy >= VIDEO_HEIGHT) continue;

        for (sx = 0; sx < w; ++sx) {
            dx = x + sx;
            if (dx < 0 || dx >= VIDEO_WIDTH) continue;

            p = pixels[sy * w + sx];
            if (p == transparent) continue;

#if USE_BACKBUFFER
            if (backbuffer != NULL) {
                backbuffer[dy * VIDEO_WIDTH + dx] = p;
            } else
#endif
            {
                VGA[dy * VIDEO_WIDTH + dx] = p;
            }
        }
    }
}

void v_set_palette_raw(const unsigned char *rgb, int count)
{
    int i;
    if (!rgb || count <= 0) return;

    if (count > 256) {
        count = 256;
    }
    memcpy(current_palette, rgb, count * 3);
    if (count < 256) {
        memset(current_palette + (count * 3), 0, (256 - count) * 3);
    }

    // VGA DAC: Ã­ndice 0x3C8, datos 0x3C9
    outp(0x3C8, 0); // Empieza en el color 0

    for (i = 0; i < count; ++i) {
        // Componentes 0..63 (6 bits)
        outp(0x3C9, rgb[i * 3 + 0]);
        outp(0x3C9, rgb[i * 3 + 1]);
        outp(0x3C9, rgb[i * 3 + 2]);
    }
}

static int v_read_palette_file(const char *filename, unsigned char *pal, int size)
{
    FILE *f;

    if (!filename || !pal || size <= 0) return 0;

    f = fopen(filename, "rb");
    if (!f) return 0;

    if (fread(pal, 1, size, f) != (size_t)size) {
        fclose(f);
        return 0;
    }

    fclose(f);
    return 1;
}

void v_load_palette(const char *filename)
{
    unsigned char pal[256 * 3];

    if (palette_locked) {
        v_set_palette_raw(locked_palette, 256);
        return;
    }

    if (!v_read_palette_file(filename, pal, sizeof(pal))) return;

    v_set_palette_raw(pal, 256);
}

void v_lock_palette(const char *filename)
{
    if (palette_locked) {
        v_set_palette_raw(locked_palette, 256);
        return;
    }

    if (!v_read_palette_file(filename, locked_palette, sizeof(locked_palette))) return;

    palette_locked = 1;
    v_set_palette_raw(locked_palette, 256);
}
